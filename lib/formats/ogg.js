// Generated by CoffeeScript 1.6.3
(function() {
  var Client, Ogg, Source, async, ogg, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  async = require("async");

  ogg = require("ogg");

  Client = require("../client").Client;

  Source = require("../source").Source;

  module.exports.Ogg = Ogg = {};

  Ogg.Client = (function(_super) {
    __extends(Client, _super);

    function Client(opts) {
      if (opts == null) {
        opts = {};
      }
      this.assemblePage = __bind(this.assemblePage, this);
      Client.__super__.constructor.apply(this, arguments);
      this._writableState.objectMode = true;
      this.source = opts.source;
      this.prepare();
    }

    Client.prototype.headerOut = function(done) {
      var _this = this;
      return async.each(this.source.streams, (function(_arg, cb) {
        var firstPage, serialno;
        serialno = _arg.serialno, firstPage = _arg.firstPage;
        return _this.assemblePage(firstPage, serialno, cb);
      }), function() {
        return async.each(_this.source.streams, (function(_arg, cb) {
          var secondPage, serialno;
          serialno = _arg.serialno, secondPage = _arg.secondPage;
          return _this.assemblePage(secondPage, serialno, cb);
        }), done);
      });
    };

    Client.prototype.prepare = function() {
      var _this = this;
      this.encoder = new ogg.Encoder;
      this.pageIndex = null;
      this.encoder.on("data", function(chunk, encoding) {
        return _this.push(chunk, encoding);
      });
      return this.encoder.on("end", function() {
        return _this.prepare();
      });
    };

    Client.prototype.getStream = function(serialno) {
      return this.encoder.streams[serialno] || this.encoder.stream(serialno);
    };

    Client.prototype.assemblePage = function(packets, serialno, done) {
      var stream,
        _this = this;
      stream = this.getStream(serialno);
      return async.each(packets, (function(packet, cb) {
        return stream.packetin(packet, cb);
      }), function() {
        return stream.flush(done);
      });
    };

    Client.prototype.onPage = function(serialno, pageIndex, callback) {
      var stream, _ref;
      this.pageIndex = pageIndex;
      stream = this.getStream(serialno);
      if (!((2 <= (_ref = this.pageIndex) && _ref <= 3))) {
        return callback();
      }
      return stream.flush(callback);
    };

    Client.prototype.addPacket = function(serialno, packet, callback) {
      var stream,
        _this = this;
      stream = this.getStream(serialno);
      return stream.packetin(packet, function() {
        if (_this.pageIndex <= 3) {
          return callback();
        }
        return stream.pageout(callback);
      });
    };

    Client.prototype._transform = function(chunk, encoding, callback) {
      var serialno;
      serialno = chunk.serialno;
      switch (chunk.type) {
        case "page":
          return this.onPage(serialno, chunk.index, callback);
        case "packet":
          return this.addPacket(serialno, chunk.data, callback);
      }
    };

    return Client;

  })(Client);

  Ogg.Source = (function(_super) {
    __extends(Source, _super);

    function Source() {
      var _this = this;
      Source.__super__.constructor.apply(this, arguments);
      this._readableState.objectMode = true;
      this.decoder = new ogg.Decoder();
      this.streams = [];
      this.decoder.on("stream", function(stream) {
        var handler, pageIndex;
        handler = {
          serialno: stream.serialno,
          firstPage: [],
          secondPage: []
        };
        _this.streams.push(handler);
        pageIndex = 0;
        stream.on("page", function() {
          pageIndex++;
          return _this.push({
            type: "page",
            serialno: stream.serialno,
            index: pageIndex
          });
        });
        stream.on("packet", function(packet) {
          switch (pageIndex) {
            case 1:
              handler.firstPage.push(packet);
              break;
            case 2:
              handler.secondPage.push(packet);
          }
          return _this.push({
            type: "packet",
            serialno: stream.serialno,
            data: packet
          });
        });
        return stream.on("eos", function() {
          return _this.streams = _.without(_this.streams, handler);
        });
      });
    }

    Source.prototype._transform = function(chunk, encoding, callback) {
      return this.decoder.write(chunk, callback);
    };

    return Source;

  })(Source);

}).call(this);
