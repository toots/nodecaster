// Generated by CoffeeScript 1.6.3
(function() {
  var Client, Mpeg, Source, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  Client = require("../client").Client;

  Source = require("../source").Source;

  module.exports.Mpeg = Mpeg = {};

  Mpeg.Client = (function(_super) {
    __extends(Client, _super);

    function Client(opts) {
      if (opts == null) {
        opts = {};
      }
      Client.__super__.constructor.apply(this, arguments);
      this.icyMetadata = opts.icyMetadata || false;
      this.icyMetadataInterval = opts.icyMetadataInterval || 16000;
      this.byteCount = 0;
    }

    Client.prototype.buildMetadataBlock = function() {
      var data, length, title;
      if (this.metadata == null) {
        data = new Buffer(1);
        data.fill(0);
        return data;
      }
      title = this.metadata.title || "Unknown title";
      if (this.metadata.artist != null) {
        title += " -- " + this.metadata.artist;
      }
      title = "StreamTitle='" + (title.replace(/'/g, "\\'")) + "';";
      if (title.length > 4080) {
        title = "" + (title.slice(0, 4080 - 5)) + "...';";
      }
      length = Math.ceil(title.length / 16);
      data = new Buffer(1 + length * 16);
      data.fill(0);
      data.writeUInt8(length, 0);
      data.write(title, 1);
      return data;
    };

    Client.prototype._transform = function(chunk, encoding, callback) {
      var after, before, data;
      if (!this.icyMetadata) {
        return Client.__super__._transform.apply(this, arguments);
      }
      data = new Buffer(chunk, encoding);
      if (this.byteCount + data.length > this.icyMetadataInterval) {
        before = data.slice(0, this.icyMetadataInterval - this.byteCount);
        after = data.slice(this.icyMetadataInterval - this.byteCount);
        this.push(Buffer.concat([before, this.buildMetadataBlock(), after]));
        this.metadata = null;
        this.byteCount = after.length;
      } else {
        this.push(data);
        this.byteCount += data.length;
      }
      return callback();
    };

    return Client;

  })(Client);

  Mpeg.Source = (function(_super) {
    __extends(Source, _super);

    function Source() {
      _ref = Source.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return Source;

  })(Source);

}).call(this);
