// Generated by CoffeeScript 1.6.3
(function() {
  var Client, Source, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  Client = require("../client").Client;

  Source = require("../source").Source;

  Client.Mpeg = (function(_super) {
    __extends(Mpeg, _super);

    function Mpeg(opts) {
      if (opts == null) {
        opts = {};
      }
      Mpeg.__super__.constructor.apply(this, arguments);
      this._writableState.objectMode = true;
      this.metadata = opts.metadata;
      this.icyMetadata = opts.icyMetadata || false;
      this.icyMetadataInterval = opts.icyMetadataInterval || 16000;
      this.byteCount = 0;
    }

    Mpeg.prototype.buildMetadataBlock = function() {
      var data, length, title;
      if (this.metadata == null) {
        data = new Buffer(1);
        data.fill(0);
        return data;
      }
      title = this.metadata.title || "Unknown title";
      if (this.metadata.artist != null) {
        title += " -- " + this.metadata.artist;
      }
      title = "StreamTitle='" + (title.replace(/'/g, "\\'")) + "';";
      if (title.length > 4080) {
        title = "" + (title.slice(0, 4080 - 5)) + "...';";
      }
      length = Math.ceil(title.length / 16);
      data = new Buffer(1 + length * 16);
      data.fill(0);
      data.writeUInt8(length, 0);
      data.write(title, 1);
      return data;
    };

    Mpeg.prototype._transform = function(chunk, encoding, callback) {
      var after, before, data;
      data = chunk.data;
      switch (chunk.type) {
        case "metadata":
          this.metadata = data;
          break;
        case "data":
          if (!this.icyMetadata) {
            this.push(data);
            return callback();
          }
          if (this.byteCount + data.length > this.icyMetadataInterval) {
            before = data.slice(0, this.icyMetadataInterval - this.byteCount);
            after = data.slice(this.icyMetadataInterval - this.byteCount);
            this.push(Buffer.concat([before, this.buildMetadataBlock(), after]));
            this.metadata = null;
            this.byteCount = after.length;
          } else {
            this.push(data);
            this.byteCount += data.length;
          }
      }
      return callback();
    };

    return Mpeg;

  })(Client);

  Source.Mpeg = (function(_super) {
    __extends(Mpeg, _super);

    function Mpeg() {
      Mpeg.__super__.constructor.apply(this, arguments);
      this._readableState.objectMode = true;
    }

    Mpeg.prototype.onMetadata = function(metadata) {
      this.metadata = metadata;
      return this.push({
        type: "metadata",
        data: metadata
      });
    };

    Mpeg.prototype._transform = function(chunk, encoding, callback) {
      this.push({
        type: "data",
        data: new Buffer(chunk, encoding)
      });
      return callback();
    };

    return Mpeg;

  })(Source);

}).call(this);
